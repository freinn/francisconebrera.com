[IMG]https://www.rust-lang.org/logos/rust-logo-blk.svg[/IMG]

[COLOR="Blue"][SIZE="4"][B]El lenguaje de programación Rust[/B][/SIZE][/COLOR]

Es un lenguaje de programación compilado creado y mantenido por Mozilla y usado en Firefox y Servo reemplazando a C++, con el rendimiento de C/C++ (en algunos casos superior), que [B]no[/B] es orientado a objetos, pero sí es:

- multiplataforma: [URL="https://github.com/rust-lang-nursery/rustup.rs/blob/master/README.md"]https://github.com/rust-lang-nursery/rustup.rs/blob/master/README.md[/URL]
- tiene un compilador muy llorón (esto es güeno) con un borrow checker muy quisquilloso también
- funcional (soporta la inmutabilidad, las clausuras y el paso de funciones como argumentos con todo lo que esto conlleva)
- imperativo, aunque distinto a los demás por el tema de los moves y los borrows
- muy bueno para programación paralela y concurrente y para hacer sistemas escalables
- soporte de [URL="https://en.wikipedia.org/wiki/Programming_in_the_large_and_programming_in_the_small"]programming in the large[/URL] mediante traits, enums (tipos de datos algebraicos) y el sistema de módulos
- (opinión personal) un lenguaje con mucho futuro, y es un gusto programar en él

Incluso se está desarollando un sistema operativo 100% en Rust, llamado [URL="https://github.com/redox-os/redox"]Redox[/URL]

[COLOR="Blue"][SIZE="4"][B]Desventajas actuales[/B][/SIZE][/COLOR]

- está [s]verde[/s] desarrollándose muy rápido en sus librerías, [s]sobre todo para programación web[/s] hasta que salió [URL="https://rocket.rs/"]rocket.rs[/URL]
- no hay mucha oferta de trabajo en este lenguaje por el momento
- curva de aprendizaje pronunciada (no tanto como Haskell), aunque cada vez hay más recursos interesantes y están trabajando en que la entrada de los novatos sea cada día más fácil.

[COLOR="Blue"][SIZE="4"][B]Instalación[/B][/SIZE][/COLOR]

[URL="https://www.rustup.rs/"]https://www.rustup.rs/[/URL]. Funciona en casi cualquier plataforma y está creciendo mucho. Recomiendo familiarizarse cuanto antes con Cargo, el gestor de crates (librerías) de Rust. Es sencillo. Y para resolver conflictos con crates usamos estos dos comandos:

cargo install cargo-tree // sólo se usa una vez
cargo tree // en cada proyecto de cargo que tenga problemas de dependencias

[COLOR="Blue"][SIZE="4"][B]Listado de webs interesantes[/B][/SIZE][/COLOR]

[URL="https://www.rust-lang.org/en-US/index.html"]Web oficial del lenguaje[/URL]
[URL="https://users.rust-lang.org/"]Foro oficial del lenguaje[/URL]
[URL="http://arewegameyet.com/"]Are we game yet?[/URL]
[URL="https://areweideyet.com/"]Are we (I)DE yet?[/URL]
[URL="http://www.arewewebyet.org/"]Are we web yet?[/URL]
[URL="http://www.newrustacean.com/"]New rustacean[/URL]
[URL="https://www.reddit.com/r/rust/"]Subreddit[/URL]
[URL="https://this-week-in-rust.org/"]This week in rust[/URL]

[COLOR="Blue"][SIZE="4"][B]Libros recomendados[/B][/SIZE][/COLOR]

[URL="https://github.com/sger/RustBooks"]https://github.com/sger/RustBooks[/URL]

Personalmente los mejores me parecen "Programming Rust", que es todavía early release pero lo tengo original y [URL="https://doc.rust-lang.org/stable/book/"]el libro oficial en su web[/URL]. Para empezar, recomiendo Programming Rust.

Los problemas más comunes al empezar con Rust son los lifetimes, los moves y los borrows, que se explican en estos dos recursos convenientemente, pero recomiendo coger lápiz y papel porque solo leyendo es complicado de entender.

[COLOR="Blue"][SIZE="4"][B]Código de conducta de los rustaceans[/B][/SIZE][/COLOR]

Lo puedes leer [URL="https://www.rust-lang.org/en-US/conduct.html"]aquí[/URL]. Me gustaría bastante que dicho código se respetara siempre en esta plataforma, y por mi parte así lo haré.

[COLOR="Blue"][SIZE="4"][B]Personalizar bash para trabajar con Rust y Git[/B][/SIZE][/COLOR]

Estas instrucciones son para distros basadas en Debian, yo uso Ubuntu 16.04 LTS:

Necesitamos [URL="https://github.com/jimeh/git-aware-prompt"]git-aware-prompt[/URL] instalado.

Los cambios que haremos serán 3:

1) añadir el comando "cls", que limpia de manera completa bash, dejándola como recién abierta, y no como hacer un clear que sólo mete \n hasta dejarla "limpia", pero conservando su historia.

2) añadir el comando "compilar-rust" que es primero ejecutar cls y luego cargo run, de este modo, obtenemos una consola limpia sólo con los errores de nuestro proyecto actual.

3) Poner color a la shell, mostrando la rama actual de git en la que nos encontremos.

Cuando bash se inicia, coge su configuración del fichero [B]~/.bashrc[/B]

En [B]~/.bashrc[/B] añadimos al final del todo:

alias cls='tput reset'
alias compilar-rust='cls && cargo run'

parse_git_branch() {
     git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}

export PS1="\[\033[01;32m\]\u@\h \[\033[01;34m\]\w\[\033[33m\]\$(parse_git_branch)\[\033[00m\] $ "

Tras realizar cambios sobre este fichero, podemos aplicarlos a la shell actual con:

$ source ~/.bashrc

[COLOR="Blue"][SIZE="4"][B]Mascota (no oficial) del lenguaje[/B][/SIZE][/COLOR]

Ferris el cangrejo:

[URL=http://www.rustacean.net/assets/rustacean-orig-noshadow.png]
[IMG]http://www.rustacean.net/assets/rustacean-orig-noshadow.png[/IMG][/URL]

[COLOR="Blue"][SIZE="4"][B]Shurcrustáceos[/B][/SIZE][/COLOR]