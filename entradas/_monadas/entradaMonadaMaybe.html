Haskell es un lenguaje temido por mucha gente, que intenta aprenderlo y se queda estancado en algún punto. Ese punto para mí fueron las mónadas, y ahora que las entiendo y uso, me permito crear un post que explique la segunda mónada más sencilla después de <strong>Id</strong>, <strong>Maybe</strong>. En realidad las mónadas no son tan complicadas como las pintan, pero en internet he visto explicaciones que no ayudan demasiado, cosa que este tutorial intenta remediar. Aquí no incluyo absurdas analogías como <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/" title="undefined" target="_blank">que las mónadas son burritos</a>, pero tampoco profundizo en las leyes matemáticas que rigen las mónadas para que todo buen haskeller que use tu mónada no se lleve sorpresas.

<h3><b>Requisitos preliminares</b></h3>
<br />

<h4><b>Tipos en Haskell</h4></b>

Lo primero que debemos saber es qué es un tipo de Haskell y cómo se declara:

[code language="haskell"]
data Maybe a = Nothing
             | Just a
             deriving Show
[/code]

A la izquierda del igual tenemos un constructor de tipos (es lo que aparecerá en las cabeceras de las funciones, y da nombre al tipo). La variable de tipo <strong>a</strong> nos indica que <strong>Maybe</strong> por sí solo no es un tipo final, sino que necesita un <strong>a</strong> para ser "completo". Esto es, tiene un kind <strong>* -> *</strong>.

Mientras a la derecha tenemos los constructores de valor. Como vemos, podemos crear el valor <strong>Nothing</strong>, o un <strong>Just a</strong>. Tanto los constructores de tipo como los de valor deben empezar por mayúscula, y los constructores de valor se separan con barras verticales '|'.

La última declaración es <b>deriving Show</b> y no es otra cosa que decirle al compilador que automáticamente nos cree la función show para poder imprimir los valores del tipo <b>Maybe a</b> por pantalla.

Es decir, podemos crear valores de tipo <strong>Maybe a</strong> como los siguientes:

Just False :: Maybe Bool
Just 15 :: Maybe Int
Just "Fran" :: Maybe String
Just (Just 42) :: Maybe (Maybe Int)
Nothing :: Maybe a

Como vemos, en el último valor, <strong>Nothing</strong>, también tenemos un <strong>Maybe a</strong>, luego puede haber muchos 'tipos' de <strong>Nothing</strong>.

Es muy importante entender que en este último ejemplo de los 5 valores de tipo <b>Maybe a</b>, a la izquierda estarían los valores de tipo <b>Maybe a</b>, luego aparece el operador '::' (que se puede leer como "tiene tipo") y a continuación el tipo al que pertenecen estos valores.

El cometido de nuestro tipo es ver si una computación produce un resultado válido (encontramos a Pepito en una base de datos, por ejemplo) o inválido para computar (no se encontró a Pepito en una base de datos), <strong>y encapsular en el tipo este contexto.</strong> Es decir, el contexto se usa como información adicional para saber qué debe ocurrir en la siguiente computación.

<h4><b>Currificación</h4></b>

Un ejemplo sencillo de currificación es el siguiente:

Si definimos la función <strong>sumar</strong>, vemos que tiene 2 parámetros de tipo <strong>Int</strong> y devuelve un valor de tipo <strong>Int</strong>:

[code language="haskell"]
sumar :: Int -> Int -> Int
sumar x y = x + y
[/code]

Esto está muy bien, con la salvedad de que es mentira (sí, me encanta mentir en mis post). La realidad es que, <strong>en Haskell todas las funciones reciben un único parámetro</strong>. Lo mejor es verlo con un ejemplo:

En Haskell, <strong>las declaraciones de tipos de funciones asocian a derechas</strong> y este código es perfectamente válido:

[code language="haskell"]
sumar :: Int -> (Int -> Int)
sumar x y = x + y
[/code]

Es decir, tenemos una función que, cuando recibe un <strong>Int</strong>, nos devuelve <strong>otra función de tipo (Int -> Int)</strong>:

[code language="haskell"]
sumar10 :: Int -> Int
sumar10 = sumar 10

-- *Main> sumar10 43
-- 53
[/code]

Como vemos, en la currificación, lo que hacemos es "comernos" parámetros que están a la izquierda en la declaración de tipos de la función  (esto nos hace recordar que la aplicación de funciones en Haskell asocia a izquierdas), hemos pasado de <strong>sumar :: Int -> Int -> Int</strong> a <strong>sumar10 :: Int -> Int</strong>. Como vemos, currificar en realidad es fijar parámetros de una función para obtener otra, que luego aplicamos a los parámetros que falten para conseguir un resultado.

[code language="haskell"]
division :: Int -> Int -> Maybe Int
division _ 0 = Nothing
division x y = Just (x `div` y)
[/code]

Necesitaremos la función <strong>flip</strong> para poder currificar una división de manera conveniente. Lo único que hace <strong>flip</strong> es cambiar el orden de sus argumentos en la aplicación de la función:

[code language="haskell"]
flip :: (a -> b -> c) -> b -> a -> c
flip f x y =  f y x
[/code]

Haciendo uso de <strong>flip</strong>, podemos <strong>fijar el denominador</strong> (esto es muy importante, al usar <strong>flip</strong> estamos currificando sobre el segundo parámetro de <strong>division</strong>) y definir la función <strong>dividirEntreDos</strong>:

[code language="haskell"]
dividirEntreDos :: Int -> Maybe Int
dividirEntreDos = flip division 2

dividirEntreCero :: Int -> Maybe Int
dividirEntreCero = flip division 0

-- *Main> dividirEntreDos 18
-- Just 9

-- *Main> dividirEntreCero 8
-- Nothing
[/code]

<h3><b>Qué son las mónadas en realidad</b></h3>

Importante pregunta, tan importante como difícil de explicar. Las mónadas son tipos que se han hecho instancia de la clase de tipos <strong>Monad</strong>. Una clase de tipos es algo parecido a una interfaz del <strike>asqueroso</strike> lenguaje Java, es decir, un conjunto de funciones constituyen la interfaz, con sus prototipos, y estamos obligados a definir todas esas funciones para la clase Java que implemente dicha interfaz, para hacerla compatible con todas esas operaciones.

Si queremos que nuestro tipo sea instancia de la clase de tipos <strong>Monad</strong>, debemos definir dos funciones:

[code language="haskell"]
class Monad m where  
    return :: a -> m a  
  
    (>>=) :: m a -> (a -> m b) -> m b  
[/code]

Al ver la palabra <strong>return</strong>, puede que pienses que la función acabará cuando llamemos a <strong>return</strong>. Nada más lejos de la realidad. La función <strong>return</strong> sólo envuelve un valor "normal", es decir, no monádico, en un contexto monádico. Veamos la definición de <strong>return</strong> para <strong>Maybe</strong>:

[code language="haskell"]
return x = (Just x)
[/code]

Ahora llegamos a la parte interesante, la clase de tipos Monad define un operador llamado 'bind' (ligar) que puedes ver en la declaración de la clase de tipos <strong>Monad</strong> un poco más arriba. La intención de bind es componer funciones que actúen sobre mónadas, dejando todo el tinglado preparado para que se pueda seguir computando en cadena. Esto tiene como consecuencia un cambio de contexto sucesivo, y es algo que los funtores por ejemplo no permiten (siempre conservan intacto su contexto). Tenemos que tener muy presente la declaración de tipos genérica para bind <strong>(>>=) :: m a -> (a -> m b) -> m b</strong>, y cambiar esa <strong>m</strong> (mónada) que vemos ahí por nuestro tipo, en este caso Maybe: <strong>(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b</strong>. Veamos el código de bind: 

[code language="haskell"]
(>>=) :: m a -> (a -> m b) -> m b
(>>=) (Just x) f = f x     -- la computación se producirá normalmente (aunque puede que dé un Nothing al ejecutar f)
(>>=) Nothing  f = Nothing -- la computación no se puede realizar y se propaga el resultado
[/code]

Vemos que en esta función hay un reconocimiento de patrones (o de constructores de valor).

Ecuación 1: Si el valor que encapsula la mónada que le pasamos a bind es válido (está en un contexto <b>Just</b>), le aplicamos una función que a partir de él, devuelve otra mónada.

Ecuación 2: Si el valor que encapsula la mónada que le pasamos a bind es inválido (no computable), lo propagamos.

Esta es la idea clave de las mónadas. Es una composición de funciones que tiene en cuenta el "estado" (contexto de la mónada, en este caso puede ser <strong>Just</strong> o <strong>Nothing</strong>) y el resultado producido por la computación (la 'a' de <strong>m 'a'</strong> en bind) para aplicarle una función que, a partir de ese resultado, nos produce una mónada lista para volver a aplicarle bind o terminar la cadena de computaciones.

A partir de GHC 7.10, para instanciar un tipo en la clase de tipos <strong>Monad</strong> debemos instanciarlo primero en la clase de tipos <strong>Functor</strong> y en la clase de tipos <strong>Applicative</strong>. Como este post no trata de funtores ni funtores aplicativos, sólo pondré la instancia para que puedas compilar un ejemplo completo: 

[code language="haskell"]
import Prelude hiding (Maybe, Nothing, Just)

data Maybe a = Nothing
             | Just a
             deriving Show

instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap _ Nothing  = Nothing

instance Applicative Maybe where
  pure                  = Just
  (Just f) <*> (Just x) = Just (f x)
  _        <*> _        = Nothing
[/code]

Ahora haremos uso de nuestra mónada (puedes ver el código completo de este post <a href="https://github.com/freinn/francisconebrera.com/blob/master/monadas/monadaMaybeCompleta.hs" title="undefined" target="_blank">en mi github</a>) para encadenar computaciones que pueden fallar, por ejemplo, las divisiones:

[code language="haskell"]
division :: Int -> Int -> Maybe Int
division _ 0 = Nothing
division x y = Just (x `div` y)
[/code]

El código es simple, las ecuaciones se comprueban de arriba a abajo hasta que una 'cuele'. La primera comprueba que el divisor sea 0, en cuyo caso no podremos computar nada, y devolvemos el valor <b>Nothing</b>. En el segundo caso, como el divisor es distinto de 0, podemos simplemente hacer la división, y encapsular el resultado en nuestra mónada.

<h3><b>Mónadas para componer funciones con contexto</b></h3>

La composición de funciones es esencial en Haskell y en todos los lenguajes de programación. Se trata simplemente de ejecutar algo como:

[code language="haskell"]
g . f
[/code]

Es decir, <strong>g</strong> después de <strong>f</strong>. Primero se aplica a algo la función <strong>f</strong>, y ese resultado pasa a <strong>g</strong>. La función de composición tiene por definición:

[code language="haskell"]
(.) :: (a -> b) -> (b -> c) -> (a -> c)
(f . g) x = f (g x)
[/code]

Ahora, intentemos componer algo con nuestro tipo <strong>Maybe</strong>:

[code language="haskell"]
(.) :: (a -> b) -> (b -> c) -> (a -> c)
[/code]

[code language="haskell"]
(Int -> Maybe Int) -> (Int -> Maybe Int) -> (Int -> Maybe Int)
[/code]

Vemos claramente que en este caso, la composición no nos será suficiente, porque la primera función que se ejecutará (<strong>g</strong>) no devuelve un <b>Int</b>, sino un <strong>Maybe Int</strong>.

Por suerte sí que podemos componer funciones que usen la mónada <strong>Maybe</strong>, haciendo llamadas sucesivas y encadenadas de bind con funciones que, a partir de un tipo no monádico nos creen una mónada <strong>Maybe</strong> con el resultado encapsulado, recordemos la definición de bind:

[code language="haskell"]
(>>=) :: m a -> (a -> m b) -> m b
(>>=) (Just x) f = f x     -- la computación se producirá normalmente (aunque puede que dé un Nothing al ejecutar f)
(>>=) Nothing  f = Nothing -- la computación no se puede realizar y se propaga el resultado
[/code]

Esta es la razón principal por la cual la abstracción de las mónadas se creó en la teoría de las categorías y luego pasó a lenguajes como Haskell, componer funciones con un contexto asociado, como por ejemplo:

[code language="haskell"]
sucesionDeDivisiones = (Just 128) >>= dividirEntreDos >>= dividirEntreDos

sucesionDeDivisionesConCero = (Just 128) >>= dividirEntreDos >>= dividirEntreCero >>= dividirEntreDos
[/code]

Espero que haya quedado clara la naturaleza de las mónadas y su intención. En potenciales futuros artículos, quizás explique mónadas un poco más complicadas y otras abstracciones propias de los lenguajes funcionales, en Haskell.

<h3><b>Notación do</b></h3>

No desesperes, esto ya es lo último, el uso de bind está bien, pero es mucho más cómodo muchas veces hacer uso de la notación do:

[code language="haskell"]
sucesionDeDivisionesDo = do
  numeroInicial <- Just 128
  resultado1 <- dividirEntreDos numeroInicial
  dividirEntreDos resultado1
[/code]

Lo más importante aquí es que las mónadas suelen conseguir <strong>ejecución ordenada</strong>, pues la aplicación sucesiva de bind bebe de acciones anteriores. Además, como decidí no usar lambdas para no sobrecomplicar los ejemplos anteriores, no se vió algo que te pongo como ejercicio, lo que ves en la notación do es que <strong>los resultados de todas las computaciones monádicas se ligan (bind) a nombres</strong>, pudiendo ser potencialmente usados para computaciones futuras.

<h4><b>Reglas de transformación a notación do</b></h4>

Se trata de dos reglas que se deben aplicar recursivamente hasta que lleguemos a un código que compile:

a <- m <br />
e <br />

Se transforma en:

m >>= \a -> e

y

m
n

se transforma en:

m >> n

El ejercicio que te pongo es que pases la función <strong>sucesionDeDivisionesDo</strong> a una definición con lambdas para que veas que las mónadas no es que sean un azúcar sintáctico pero sí que pueden actuar de esa manera.

<h3><b>Conclusión</b></h3>

Hemos visto varios usos de las mónadas:

- Encadenar (componer) computaciones con contexto asociado de manera "mágica" definiendo la lógica de transformación sólo una vez, en bind. Esto hace que de computaciones sencillas podamos crear fácilmente otras más complicadas.
- Ejecución ordenada de funciones en un lenguaje funcional.
- Enlace automático a nombres de los resultados de nuestras computaciones, para poder usarlos más adelante.

Espero que este tutorial te haya servido para comprender las mónadas y qué son en realidad, sin analogías innecesarias.